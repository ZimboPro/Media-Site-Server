/**
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.7.7
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { BaseItemDtoQueryResult } from '../model/models';
import { EncodingContext } from '../model/models';
import { ProblemDetails } from '../model/models';
import { SubtitleDeliveryMethod } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class VideosService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Removes alternate video sources.
     * @param itemId The item id.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteAlternateSources(itemId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<any>;
    public deleteAlternateSources(itemId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<HttpResponse<any>>;
    public deleteAlternateSources(itemId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<HttpEvent<any>>;
    public deleteAlternateSources(itemId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<any> {
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling deleteAlternateSources.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (CustomAuthentication) required
        localVarCredential = this.configuration.lookupCredential('CustomAuthentication');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('X-Emby-Authorization', localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json',
                'application/json; profile=CamelCase',
                'application/json; profile=PascalCase'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.delete<any>(`${this.configuration.basePath}/Videos/${encodeURIComponent(String(itemId))}/AlternateSources`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets additional parts for a video.
     * @param itemId The item id.
     * @param userId Optional. Filter by user id, and attach user data.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAdditionalPart(itemId: string, userId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<BaseItemDtoQueryResult>;
    public getAdditionalPart(itemId: string, userId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<HttpResponse<BaseItemDtoQueryResult>>;
    public getAdditionalPart(itemId: string, userId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<HttpEvent<BaseItemDtoQueryResult>>;
    public getAdditionalPart(itemId: string, userId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<any> {
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling getAdditionalPart.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (userId !== undefined && userId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>userId, 'userId');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (CustomAuthentication) required
        localVarCredential = this.configuration.lookupCredential('CustomAuthentication');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('X-Emby-Authorization', localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json',
                'application/json; profile=CamelCase',
                'application/json; profile=PascalCase'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<BaseItemDtoQueryResult>(`${this.configuration.basePath}/Videos/${encodeURIComponent(String(itemId))}/AdditionalParts`,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a video stream.
     * @param itemId The item id.
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param params The streaming parameters.
     * @param tag The tag.
     * @param deviceProfileId Optional. The dlna device profile id to utilize.
     * @param playSessionId The play session id.
     * @param segmentContainer The segment container.
     * @param segmentLength The segment length.
     * @param minSegments The minimum number of segments.
     * @param mediaSourceId The media version id, if playing an alternate version.
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames.
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param maxAudioBitDepth Optional. The maximum audio bit depth.
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param width Optional. The fixed horizontal resolution of the encoded video.
     * @param height Optional. The fixed vertical resolution of the encoded video.
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param subtitleMethod Optional. Specify the subtitle delivery method.
     * @param maxRefFrames Optional.
     * @param maxVideoBitDepth Optional. The maximum video bit depth.
     * @param requireAvc Optional. Whether to require avc.
     * @param deInterlace Optional. Whether to deinterlace the video.
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use.
     * @param liveStreamId The live stream id.
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to.
     * @param transcodeReasons Optional. The transcoding reason.
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param streamOptions Optional. The streaming options.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVideoStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<Blob>;
    public getVideoStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<HttpResponse<Blob>>;
    public getVideoStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<HttpEvent<Blob>>;
    public getVideoStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'video/_*'}): Observable<any> {
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling getVideoStream.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (container !== undefined && container !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>container, 'container');
        }
        if (_static !== undefined && _static !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>_static, 'static');
        }
        if (params !== undefined && params !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>params, 'params');
        }
        if (tag !== undefined && tag !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>tag, 'tag');
        }
        if (deviceProfileId !== undefined && deviceProfileId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceProfileId, 'deviceProfileId');
        }
        if (playSessionId !== undefined && playSessionId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>playSessionId, 'playSessionId');
        }
        if (segmentContainer !== undefined && segmentContainer !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>segmentContainer, 'segmentContainer');
        }
        if (segmentLength !== undefined && segmentLength !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>segmentLength, 'segmentLength');
        }
        if (minSegments !== undefined && minSegments !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minSegments, 'minSegments');
        }
        if (mediaSourceId !== undefined && mediaSourceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>mediaSourceId, 'mediaSourceId');
        }
        if (deviceId !== undefined && deviceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceId, 'deviceId');
        }
        if (audioCodec !== undefined && audioCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioCodec, 'audioCodec');
        }
        if (enableAutoStreamCopy !== undefined && enableAutoStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableAutoStreamCopy, 'enableAutoStreamCopy');
        }
        if (allowVideoStreamCopy !== undefined && allowVideoStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowVideoStreamCopy, 'allowVideoStreamCopy');
        }
        if (allowAudioStreamCopy !== undefined && allowAudioStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowAudioStreamCopy, 'allowAudioStreamCopy');
        }
        if (breakOnNonKeyFrames !== undefined && breakOnNonKeyFrames !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>breakOnNonKeyFrames, 'breakOnNonKeyFrames');
        }
        if (audioSampleRate !== undefined && audioSampleRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioSampleRate, 'audioSampleRate');
        }
        if (maxAudioBitDepth !== undefined && maxAudioBitDepth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxAudioBitDepth, 'maxAudioBitDepth');
        }
        if (audioBitRate !== undefined && audioBitRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioBitRate, 'audioBitRate');
        }
        if (audioChannels !== undefined && audioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioChannels, 'audioChannels');
        }
        if (maxAudioChannels !== undefined && maxAudioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxAudioChannels, 'maxAudioChannels');
        }
        if (profile !== undefined && profile !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>profile, 'profile');
        }
        if (level !== undefined && level !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>level, 'level');
        }
        if (framerate !== undefined && framerate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>framerate, 'framerate');
        }
        if (maxFramerate !== undefined && maxFramerate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxFramerate, 'maxFramerate');
        }
        if (copyTimestamps !== undefined && copyTimestamps !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>copyTimestamps, 'copyTimestamps');
        }
        if (startTimeTicks !== undefined && startTimeTicks !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>startTimeTicks, 'startTimeTicks');
        }
        if (width !== undefined && width !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>width, 'width');
        }
        if (height !== undefined && height !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>height, 'height');
        }
        if (maxWidth !== undefined && maxWidth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxWidth, 'maxWidth');
        }
        if (maxHeight !== undefined && maxHeight !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxHeight, 'maxHeight');
        }
        if (videoBitRate !== undefined && videoBitRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoBitRate, 'videoBitRate');
        }
        if (subtitleStreamIndex !== undefined && subtitleStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleStreamIndex, 'subtitleStreamIndex');
        }
        if (subtitleMethod !== undefined && subtitleMethod !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleMethod, 'subtitleMethod');
        }
        if (maxRefFrames !== undefined && maxRefFrames !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxRefFrames, 'maxRefFrames');
        }
        if (maxVideoBitDepth !== undefined && maxVideoBitDepth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxVideoBitDepth, 'maxVideoBitDepth');
        }
        if (requireAvc !== undefined && requireAvc !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>requireAvc, 'requireAvc');
        }
        if (deInterlace !== undefined && deInterlace !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deInterlace, 'deInterlace');
        }
        if (requireNonAnamorphic !== undefined && requireNonAnamorphic !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>requireNonAnamorphic, 'requireNonAnamorphic');
        }
        if (transcodingMaxAudioChannels !== undefined && transcodingMaxAudioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>transcodingMaxAudioChannels, 'transcodingMaxAudioChannels');
        }
        if (cpuCoreLimit !== undefined && cpuCoreLimit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>cpuCoreLimit, 'cpuCoreLimit');
        }
        if (liveStreamId !== undefined && liveStreamId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>liveStreamId, 'liveStreamId');
        }
        if (enableMpegtsM2TsMode !== undefined && enableMpegtsM2TsMode !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableMpegtsM2TsMode, 'enableMpegtsM2TsMode');
        }
        if (videoCodec !== undefined && videoCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoCodec, 'videoCodec');
        }
        if (subtitleCodec !== undefined && subtitleCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleCodec, 'subtitleCodec');
        }
        if (transcodeReasons !== undefined && transcodeReasons !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>transcodeReasons, 'transcodeReasons');
        }
        if (audioStreamIndex !== undefined && audioStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioStreamIndex, 'audioStreamIndex');
        }
        if (videoStreamIndex !== undefined && videoStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoStreamIndex, 'videoStreamIndex');
        }
        if (context !== undefined && context !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>context, 'context');
        }
        if (streamOptions !== undefined && streamOptions !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>streamOptions, 'streamOptions');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'video/_*'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        return this.httpClient.get(`${this.configuration.basePath}/Videos/${encodeURIComponent(String(itemId))}/stream`,
            {
                params: localVarQueryParameters,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a video stream.
     * @param itemId The item id.
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param params The streaming parameters.
     * @param tag The tag.
     * @param deviceProfileId Optional. The dlna device profile id to utilize.
     * @param playSessionId The play session id.
     * @param segmentContainer The segment container.
     * @param segmentLength The segment length.
     * @param minSegments The minimum number of segments.
     * @param mediaSourceId The media version id, if playing an alternate version.
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames.
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param maxAudioBitDepth Optional. The maximum audio bit depth.
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param width Optional. The fixed horizontal resolution of the encoded video.
     * @param height Optional. The fixed vertical resolution of the encoded video.
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param subtitleMethod Optional. Specify the subtitle delivery method.
     * @param maxRefFrames Optional.
     * @param maxVideoBitDepth Optional. The maximum video bit depth.
     * @param requireAvc Optional. Whether to require avc.
     * @param deInterlace Optional. Whether to deinterlace the video.
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use.
     * @param liveStreamId The live stream id.
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to.
     * @param transcodeReasons Optional. The transcoding reason.
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param streamOptions Optional. The streaming options.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVideoStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<Blob>;
    public getVideoStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<HttpResponse<Blob>>;
    public getVideoStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<HttpEvent<Blob>>;
    public getVideoStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'video/_*'}): Observable<any> {
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling getVideoStreamByContainer.');
        }
        if (container === null || container === undefined) {
            throw new Error('Required parameter container was null or undefined when calling getVideoStreamByContainer.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (_static !== undefined && _static !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>_static, 'static');
        }
        if (params !== undefined && params !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>params, 'params');
        }
        if (tag !== undefined && tag !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>tag, 'tag');
        }
        if (deviceProfileId !== undefined && deviceProfileId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceProfileId, 'deviceProfileId');
        }
        if (playSessionId !== undefined && playSessionId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>playSessionId, 'playSessionId');
        }
        if (segmentContainer !== undefined && segmentContainer !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>segmentContainer, 'segmentContainer');
        }
        if (segmentLength !== undefined && segmentLength !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>segmentLength, 'segmentLength');
        }
        if (minSegments !== undefined && minSegments !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minSegments, 'minSegments');
        }
        if (mediaSourceId !== undefined && mediaSourceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>mediaSourceId, 'mediaSourceId');
        }
        if (deviceId !== undefined && deviceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceId, 'deviceId');
        }
        if (audioCodec !== undefined && audioCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioCodec, 'audioCodec');
        }
        if (enableAutoStreamCopy !== undefined && enableAutoStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableAutoStreamCopy, 'enableAutoStreamCopy');
        }
        if (allowVideoStreamCopy !== undefined && allowVideoStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowVideoStreamCopy, 'allowVideoStreamCopy');
        }
        if (allowAudioStreamCopy !== undefined && allowAudioStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowAudioStreamCopy, 'allowAudioStreamCopy');
        }
        if (breakOnNonKeyFrames !== undefined && breakOnNonKeyFrames !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>breakOnNonKeyFrames, 'breakOnNonKeyFrames');
        }
        if (audioSampleRate !== undefined && audioSampleRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioSampleRate, 'audioSampleRate');
        }
        if (maxAudioBitDepth !== undefined && maxAudioBitDepth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxAudioBitDepth, 'maxAudioBitDepth');
        }
        if (audioBitRate !== undefined && audioBitRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioBitRate, 'audioBitRate');
        }
        if (audioChannels !== undefined && audioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioChannels, 'audioChannels');
        }
        if (maxAudioChannels !== undefined && maxAudioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxAudioChannels, 'maxAudioChannels');
        }
        if (profile !== undefined && profile !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>profile, 'profile');
        }
        if (level !== undefined && level !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>level, 'level');
        }
        if (framerate !== undefined && framerate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>framerate, 'framerate');
        }
        if (maxFramerate !== undefined && maxFramerate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxFramerate, 'maxFramerate');
        }
        if (copyTimestamps !== undefined && copyTimestamps !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>copyTimestamps, 'copyTimestamps');
        }
        if (startTimeTicks !== undefined && startTimeTicks !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>startTimeTicks, 'startTimeTicks');
        }
        if (width !== undefined && width !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>width, 'width');
        }
        if (height !== undefined && height !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>height, 'height');
        }
        if (maxWidth !== undefined && maxWidth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxWidth, 'maxWidth');
        }
        if (maxHeight !== undefined && maxHeight !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxHeight, 'maxHeight');
        }
        if (videoBitRate !== undefined && videoBitRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoBitRate, 'videoBitRate');
        }
        if (subtitleStreamIndex !== undefined && subtitleStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleStreamIndex, 'subtitleStreamIndex');
        }
        if (subtitleMethod !== undefined && subtitleMethod !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleMethod, 'subtitleMethod');
        }
        if (maxRefFrames !== undefined && maxRefFrames !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxRefFrames, 'maxRefFrames');
        }
        if (maxVideoBitDepth !== undefined && maxVideoBitDepth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxVideoBitDepth, 'maxVideoBitDepth');
        }
        if (requireAvc !== undefined && requireAvc !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>requireAvc, 'requireAvc');
        }
        if (deInterlace !== undefined && deInterlace !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deInterlace, 'deInterlace');
        }
        if (requireNonAnamorphic !== undefined && requireNonAnamorphic !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>requireNonAnamorphic, 'requireNonAnamorphic');
        }
        if (transcodingMaxAudioChannels !== undefined && transcodingMaxAudioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>transcodingMaxAudioChannels, 'transcodingMaxAudioChannels');
        }
        if (cpuCoreLimit !== undefined && cpuCoreLimit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>cpuCoreLimit, 'cpuCoreLimit');
        }
        if (liveStreamId !== undefined && liveStreamId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>liveStreamId, 'liveStreamId');
        }
        if (enableMpegtsM2TsMode !== undefined && enableMpegtsM2TsMode !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableMpegtsM2TsMode, 'enableMpegtsM2TsMode');
        }
        if (videoCodec !== undefined && videoCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoCodec, 'videoCodec');
        }
        if (subtitleCodec !== undefined && subtitleCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleCodec, 'subtitleCodec');
        }
        if (transcodeReasons !== undefined && transcodeReasons !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>transcodeReasons, 'transcodeReasons');
        }
        if (audioStreamIndex !== undefined && audioStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioStreamIndex, 'audioStreamIndex');
        }
        if (videoStreamIndex !== undefined && videoStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoStreamIndex, 'videoStreamIndex');
        }
        if (context !== undefined && context !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>context, 'context');
        }
        if (streamOptions !== undefined && streamOptions !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>streamOptions, 'streamOptions');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'video/_*'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        return this.httpClient.get(`${this.configuration.basePath}/Videos/${encodeURIComponent(String(itemId))}/stream.${encodeURIComponent(String(container))}`,
            {
                params: localVarQueryParameters,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a video stream.
     * @param itemId The item id.
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param params The streaming parameters.
     * @param tag The tag.
     * @param deviceProfileId Optional. The dlna device profile id to utilize.
     * @param playSessionId The play session id.
     * @param segmentContainer The segment container.
     * @param segmentLength The segment length.
     * @param minSegments The minimum number of segments.
     * @param mediaSourceId The media version id, if playing an alternate version.
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames.
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param maxAudioBitDepth Optional. The maximum audio bit depth.
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param width Optional. The fixed horizontal resolution of the encoded video.
     * @param height Optional. The fixed vertical resolution of the encoded video.
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param subtitleMethod Optional. Specify the subtitle delivery method.
     * @param maxRefFrames Optional.
     * @param maxVideoBitDepth Optional. The maximum video bit depth.
     * @param requireAvc Optional. Whether to require avc.
     * @param deInterlace Optional. Whether to deinterlace the video.
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use.
     * @param liveStreamId The live stream id.
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to.
     * @param transcodeReasons Optional. The transcoding reason.
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param streamOptions Optional. The streaming options.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public headVideoStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<Blob>;
    public headVideoStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<HttpResponse<Blob>>;
    public headVideoStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<HttpEvent<Blob>>;
    public headVideoStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'video/_*'}): Observable<any> {
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling headVideoStream.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (container !== undefined && container !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>container, 'container');
        }
        if (_static !== undefined && _static !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>_static, 'static');
        }
        if (params !== undefined && params !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>params, 'params');
        }
        if (tag !== undefined && tag !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>tag, 'tag');
        }
        if (deviceProfileId !== undefined && deviceProfileId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceProfileId, 'deviceProfileId');
        }
        if (playSessionId !== undefined && playSessionId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>playSessionId, 'playSessionId');
        }
        if (segmentContainer !== undefined && segmentContainer !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>segmentContainer, 'segmentContainer');
        }
        if (segmentLength !== undefined && segmentLength !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>segmentLength, 'segmentLength');
        }
        if (minSegments !== undefined && minSegments !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minSegments, 'minSegments');
        }
        if (mediaSourceId !== undefined && mediaSourceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>mediaSourceId, 'mediaSourceId');
        }
        if (deviceId !== undefined && deviceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceId, 'deviceId');
        }
        if (audioCodec !== undefined && audioCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioCodec, 'audioCodec');
        }
        if (enableAutoStreamCopy !== undefined && enableAutoStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableAutoStreamCopy, 'enableAutoStreamCopy');
        }
        if (allowVideoStreamCopy !== undefined && allowVideoStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowVideoStreamCopy, 'allowVideoStreamCopy');
        }
        if (allowAudioStreamCopy !== undefined && allowAudioStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowAudioStreamCopy, 'allowAudioStreamCopy');
        }
        if (breakOnNonKeyFrames !== undefined && breakOnNonKeyFrames !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>breakOnNonKeyFrames, 'breakOnNonKeyFrames');
        }
        if (audioSampleRate !== undefined && audioSampleRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioSampleRate, 'audioSampleRate');
        }
        if (maxAudioBitDepth !== undefined && maxAudioBitDepth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxAudioBitDepth, 'maxAudioBitDepth');
        }
        if (audioBitRate !== undefined && audioBitRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioBitRate, 'audioBitRate');
        }
        if (audioChannels !== undefined && audioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioChannels, 'audioChannels');
        }
        if (maxAudioChannels !== undefined && maxAudioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxAudioChannels, 'maxAudioChannels');
        }
        if (profile !== undefined && profile !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>profile, 'profile');
        }
        if (level !== undefined && level !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>level, 'level');
        }
        if (framerate !== undefined && framerate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>framerate, 'framerate');
        }
        if (maxFramerate !== undefined && maxFramerate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxFramerate, 'maxFramerate');
        }
        if (copyTimestamps !== undefined && copyTimestamps !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>copyTimestamps, 'copyTimestamps');
        }
        if (startTimeTicks !== undefined && startTimeTicks !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>startTimeTicks, 'startTimeTicks');
        }
        if (width !== undefined && width !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>width, 'width');
        }
        if (height !== undefined && height !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>height, 'height');
        }
        if (maxWidth !== undefined && maxWidth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxWidth, 'maxWidth');
        }
        if (maxHeight !== undefined && maxHeight !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxHeight, 'maxHeight');
        }
        if (videoBitRate !== undefined && videoBitRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoBitRate, 'videoBitRate');
        }
        if (subtitleStreamIndex !== undefined && subtitleStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleStreamIndex, 'subtitleStreamIndex');
        }
        if (subtitleMethod !== undefined && subtitleMethod !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleMethod, 'subtitleMethod');
        }
        if (maxRefFrames !== undefined && maxRefFrames !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxRefFrames, 'maxRefFrames');
        }
        if (maxVideoBitDepth !== undefined && maxVideoBitDepth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxVideoBitDepth, 'maxVideoBitDepth');
        }
        if (requireAvc !== undefined && requireAvc !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>requireAvc, 'requireAvc');
        }
        if (deInterlace !== undefined && deInterlace !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deInterlace, 'deInterlace');
        }
        if (requireNonAnamorphic !== undefined && requireNonAnamorphic !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>requireNonAnamorphic, 'requireNonAnamorphic');
        }
        if (transcodingMaxAudioChannels !== undefined && transcodingMaxAudioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>transcodingMaxAudioChannels, 'transcodingMaxAudioChannels');
        }
        if (cpuCoreLimit !== undefined && cpuCoreLimit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>cpuCoreLimit, 'cpuCoreLimit');
        }
        if (liveStreamId !== undefined && liveStreamId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>liveStreamId, 'liveStreamId');
        }
        if (enableMpegtsM2TsMode !== undefined && enableMpegtsM2TsMode !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableMpegtsM2TsMode, 'enableMpegtsM2TsMode');
        }
        if (videoCodec !== undefined && videoCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoCodec, 'videoCodec');
        }
        if (subtitleCodec !== undefined && subtitleCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleCodec, 'subtitleCodec');
        }
        if (transcodeReasons !== undefined && transcodeReasons !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>transcodeReasons, 'transcodeReasons');
        }
        if (audioStreamIndex !== undefined && audioStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioStreamIndex, 'audioStreamIndex');
        }
        if (videoStreamIndex !== undefined && videoStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoStreamIndex, 'videoStreamIndex');
        }
        if (context !== undefined && context !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>context, 'context');
        }
        if (streamOptions !== undefined && streamOptions !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>streamOptions, 'streamOptions');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'video/_*'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        return this.httpClient.head(`${this.configuration.basePath}/Videos/${encodeURIComponent(String(itemId))}/stream`,
            {
                params: localVarQueryParameters,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a video stream.
     * @param itemId The item id.
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param params The streaming parameters.
     * @param tag The tag.
     * @param deviceProfileId Optional. The dlna device profile id to utilize.
     * @param playSessionId The play session id.
     * @param segmentContainer The segment container.
     * @param segmentLength The segment length.
     * @param minSegments The minimum number of segments.
     * @param mediaSourceId The media version id, if playing an alternate version.
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames.
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param maxAudioBitDepth Optional. The maximum audio bit depth.
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param width Optional. The fixed horizontal resolution of the encoded video.
     * @param height Optional. The fixed vertical resolution of the encoded video.
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param subtitleMethod Optional. Specify the subtitle delivery method.
     * @param maxRefFrames Optional.
     * @param maxVideoBitDepth Optional. The maximum video bit depth.
     * @param requireAvc Optional. Whether to require avc.
     * @param deInterlace Optional. Whether to deinterlace the video.
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use.
     * @param liveStreamId The live stream id.
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to.
     * @param transcodeReasons Optional. The transcoding reason.
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param streamOptions Optional. The streaming options.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public headVideoStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<Blob>;
    public headVideoStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<HttpResponse<Blob>>;
    public headVideoStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'video/_*'}): Observable<HttpEvent<Blob>>;
    public headVideoStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, maxWidth?: number, maxHeight?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodeReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'video/_*'}): Observable<any> {
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling headVideoStreamByContainer.');
        }
        if (container === null || container === undefined) {
            throw new Error('Required parameter container was null or undefined when calling headVideoStreamByContainer.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (_static !== undefined && _static !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>_static, 'static');
        }
        if (params !== undefined && params !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>params, 'params');
        }
        if (tag !== undefined && tag !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>tag, 'tag');
        }
        if (deviceProfileId !== undefined && deviceProfileId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceProfileId, 'deviceProfileId');
        }
        if (playSessionId !== undefined && playSessionId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>playSessionId, 'playSessionId');
        }
        if (segmentContainer !== undefined && segmentContainer !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>segmentContainer, 'segmentContainer');
        }
        if (segmentLength !== undefined && segmentLength !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>segmentLength, 'segmentLength');
        }
        if (minSegments !== undefined && minSegments !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>minSegments, 'minSegments');
        }
        if (mediaSourceId !== undefined && mediaSourceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>mediaSourceId, 'mediaSourceId');
        }
        if (deviceId !== undefined && deviceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceId, 'deviceId');
        }
        if (audioCodec !== undefined && audioCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioCodec, 'audioCodec');
        }
        if (enableAutoStreamCopy !== undefined && enableAutoStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableAutoStreamCopy, 'enableAutoStreamCopy');
        }
        if (allowVideoStreamCopy !== undefined && allowVideoStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowVideoStreamCopy, 'allowVideoStreamCopy');
        }
        if (allowAudioStreamCopy !== undefined && allowAudioStreamCopy !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>allowAudioStreamCopy, 'allowAudioStreamCopy');
        }
        if (breakOnNonKeyFrames !== undefined && breakOnNonKeyFrames !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>breakOnNonKeyFrames, 'breakOnNonKeyFrames');
        }
        if (audioSampleRate !== undefined && audioSampleRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioSampleRate, 'audioSampleRate');
        }
        if (maxAudioBitDepth !== undefined && maxAudioBitDepth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxAudioBitDepth, 'maxAudioBitDepth');
        }
        if (audioBitRate !== undefined && audioBitRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioBitRate, 'audioBitRate');
        }
        if (audioChannels !== undefined && audioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioChannels, 'audioChannels');
        }
        if (maxAudioChannels !== undefined && maxAudioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxAudioChannels, 'maxAudioChannels');
        }
        if (profile !== undefined && profile !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>profile, 'profile');
        }
        if (level !== undefined && level !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>level, 'level');
        }
        if (framerate !== undefined && framerate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>framerate, 'framerate');
        }
        if (maxFramerate !== undefined && maxFramerate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxFramerate, 'maxFramerate');
        }
        if (copyTimestamps !== undefined && copyTimestamps !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>copyTimestamps, 'copyTimestamps');
        }
        if (startTimeTicks !== undefined && startTimeTicks !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>startTimeTicks, 'startTimeTicks');
        }
        if (width !== undefined && width !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>width, 'width');
        }
        if (height !== undefined && height !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>height, 'height');
        }
        if (maxWidth !== undefined && maxWidth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxWidth, 'maxWidth');
        }
        if (maxHeight !== undefined && maxHeight !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxHeight, 'maxHeight');
        }
        if (videoBitRate !== undefined && videoBitRate !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoBitRate, 'videoBitRate');
        }
        if (subtitleStreamIndex !== undefined && subtitleStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleStreamIndex, 'subtitleStreamIndex');
        }
        if (subtitleMethod !== undefined && subtitleMethod !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleMethod, 'subtitleMethod');
        }
        if (maxRefFrames !== undefined && maxRefFrames !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxRefFrames, 'maxRefFrames');
        }
        if (maxVideoBitDepth !== undefined && maxVideoBitDepth !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>maxVideoBitDepth, 'maxVideoBitDepth');
        }
        if (requireAvc !== undefined && requireAvc !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>requireAvc, 'requireAvc');
        }
        if (deInterlace !== undefined && deInterlace !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deInterlace, 'deInterlace');
        }
        if (requireNonAnamorphic !== undefined && requireNonAnamorphic !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>requireNonAnamorphic, 'requireNonAnamorphic');
        }
        if (transcodingMaxAudioChannels !== undefined && transcodingMaxAudioChannels !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>transcodingMaxAudioChannels, 'transcodingMaxAudioChannels');
        }
        if (cpuCoreLimit !== undefined && cpuCoreLimit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>cpuCoreLimit, 'cpuCoreLimit');
        }
        if (liveStreamId !== undefined && liveStreamId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>liveStreamId, 'liveStreamId');
        }
        if (enableMpegtsM2TsMode !== undefined && enableMpegtsM2TsMode !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>enableMpegtsM2TsMode, 'enableMpegtsM2TsMode');
        }
        if (videoCodec !== undefined && videoCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoCodec, 'videoCodec');
        }
        if (subtitleCodec !== undefined && subtitleCodec !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>subtitleCodec, 'subtitleCodec');
        }
        if (transcodeReasons !== undefined && transcodeReasons !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>transcodeReasons, 'transcodeReasons');
        }
        if (audioStreamIndex !== undefined && audioStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>audioStreamIndex, 'audioStreamIndex');
        }
        if (videoStreamIndex !== undefined && videoStreamIndex !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>videoStreamIndex, 'videoStreamIndex');
        }
        if (context !== undefined && context !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>context, 'context');
        }
        if (streamOptions !== undefined && streamOptions !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>streamOptions, 'streamOptions');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'video/_*'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        return this.httpClient.head(`${this.configuration.basePath}/Videos/${encodeURIComponent(String(itemId))}/stream.${encodeURIComponent(String(container))}`,
            {
                params: localVarQueryParameters,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Merges videos into a single record.
     * @param ids Item id list. This allows multiple, comma delimited.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mergeVersions(ids: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<any>;
    public mergeVersions(ids: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<HttpResponse<any>>;
    public mergeVersions(ids: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<HttpEvent<any>>;
    public mergeVersions(ids: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/json; profile&#x3D;CamelCase' | 'application/json; profile&#x3D;PascalCase'}): Observable<any> {
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling mergeVersions.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ids) {
            ids.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'ids');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (CustomAuthentication) required
        localVarCredential = this.configuration.lookupCredential('CustomAuthentication');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('X-Emby-Authorization', localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json',
                'application/json; profile=CamelCase',
                'application/json; profile=PascalCase'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/Videos/MergeVersions`,
            null,
            {
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                localVarHeaders: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
